<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link href="/yoke-website/css/root.css" rel="stylesheet" />
    <title>
      Yoke
    </title>
  </head>
  <body>
    <label class="hamburger-menu">
      <input type="checkbox" />
    </label>
    <aside class="side-panel">
      <nav>
        <div>
          <a href="/yoke-website/">
            home
          </a>
        </div>
        <hr />
        <div>
          <a href="/yoke-website/pages/concepts.html">
            concepts
          </a>
        </div>
        <hr />
        <div>
          <a href="/yoke-website/pages/cli.html">
            CLI reference
          </a>
        </div>
        <hr />
        <div>
          <a href="/yoke-website/pages/examples.html">
            examples
          </a>
        </div>
        <hr />
        <div>
          <a href="/yoke-website/pages/helm_compatibility.html">
            helm compatibility
          </a>
        </div>
        <hr />
        <div>
          <a href="/yoke-website/pages/yokecd.html">
            yokeCD
          </a>
        </div>
      </nav>
    </aside>
    <div class="github-link">
      <img src="/yoke-website/images/github-mark-white.svg" />
      <a href="https://github.com/davidmdm/yoke">
        yoke
      </a>
    </div>
    <main>
      <h1 id="welcome-header">
        Yoke: Introducing the Infrastructure as Code
        <br />
        Package Manager for Kubernetes
      </h1>
      <section class="container">
        <h2>
          Getting started
        </h2>
        <h3>
          Install the Yoke CLI
        </h3>
        <h4>
          From source
        </h4>
        <pre><code class="language-bash">go install github.com/davidmdm/yoke/cmd/yoke@latest</code></pre>
        <h3>
          Deploy your first package
        </h3>
        <pre><code class="language-bash">yoke takeoff my-release https://my-domain.com/example.v1.wasm</code></pre>
        <h3>
          Visit the core docs
        </h3>
        <ul>
          <li>
            <a href="/yoke-website/pages/concepts.html">
              concepts
            </a>
          </li>
          <li>
            <a href="/yoke-website/pages/examples.html">
              examples
            </a>
          </li>
        </ul>
      </section>
      <section class="container">
        <h2>
          What is Yoke?
        </h2>
        <p>
          Yoke is a Kubernetes package manager that facilitates the downloading and deployment of packages to Kubernetes. The
          primary distinction between Yoke and other Kubernetes package managers, such as Helm and Timoni, lies in how Yoke
          describes
          <strong>
            Flights
          </strong>
          (Flights are to Yoke what Charts are to Helm). Unlike Helm and Timoni, where
          Packages are defined using YAML, CUE, or nother data/configuration languages,
          <strong>
            yoke utilizes general-purpose code to describe kubernetes packages
          </strong>
          .
        </p>
        <p>
          With yoke,
          <strong
      >
            Flights are programs that generate the desired Kubernetes resources in either JSON or YAML format and output them
            to stdout
          </strong
    >
          . Flights are typically packaged as
          <strong>
            WebAssembly (wasm) executables
          </strong>
          , with Yoke embedding Wazero, a
          zero-dependency wasm runtime for Go, to execute these programs.
        </p>
        <p>
          Creating reusable building blocks for yoke is akin to writing functions or libraries. These components can be
          distributed and versioned using the respective language's ecosystem package manager, such as npm, cargo, or Go
          modules. Any language that compiles to wasm enjoys first-class support in Yoke. If your chosen language does not
          compile to wasm, you can still invoke the program and pipe the output directly to Yoke. However, this approach comes
          with certain drawbacks, including potential issues related to portability and security.
        </p>
      </section>
      <section class="container">
        <h2>
          Why Yoke? Why Another Package Manager?
        </h2>
        <p>
          As the DevOps ecosystem transitions from a focus on DevOps to platform engineering, our tools for interfacing with
          Kubernetes (K8s) must evolve accordingly. Describing Kubernetes resources through text templates represents the
          minimum standard we have set. However, it is evident that this approach is not tailored for software engineers. It
          lacks essential features such as proper type safety, compiler guarantees, validation, testing, autocompletion, and
          consistent IDE support.
        </p>
        <p>
          The crucial observation to note is that Kubernetes (K8s) resources differ fundamentally from web pages or emails.
          So, why do we use templates as if they were? These files represent diverse APIs supported by Kubernetes; in essence,
          they are structured data. The most effective tools for handling structured data are programming languages.
        </p>
      </section>
    </main>
    <footer></footer>
  </body>
  <link href="/yoke-website/css/prism-vsc-dark.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
  <script type="module">
    Prism?.highlightAll();
  </script>
</html>