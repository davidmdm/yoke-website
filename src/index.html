<h1 id="welcome-header">
  Yoke: Introducing the Infrastructure as Code<br />
  Package Manager for Kubernetes
</h1>

<section class="container">
  <h2>Getting started</h2>

  <h3>Install the Yoke CLI</h3>
  <h4>From source</h4>
  <pre><code class="language-bash">go install github.com/davidmdm/yoke/cmd/yoke@latest</code></pre>

  <h3>Deploy your first package</h3>
  <pre><code class="language-bash">yoke takeoff my-release https://my-domain.com/example/v1/main.wasm.gz</code></pre>

  <h3>Visit the core docs</h3>
  <ul>
    <li>
      <a href="/yoke-website/pages/concepts.html">concepts</a>
    </li>
    <li>
      <a href="/yoke-website/pages/examples.html">examples</a>
    </li>
    <li>
      <a href="/yoke-website/pages/yokecd.html">integrate with ArgoCD</a>
    </li>
  </ul>
</section>

<section class="container">
  <h2>What is Yoke?</h2>
  <p>Yoke is a Kubernetes package manager that facilitates the downloading and deployment of packages to Kubernetes.</p>
  <p>
    The primary distinction between Yoke and other Kubernetes package managers, such as Helm and Timoni, lies in how
    Yoke describes packages. In the context of yoke packages are called <strong>Flights</strong> (Flights are to Yoke
    what Charts are to Helm). Unlike Helm and Timoni, where Packages are defined using YAML, CUE, or other
    data/configuration languages, <strong>yoke utilizes general-purpose code to describe kubernetes packages</strong>.
  </p>

  <p>
    With yoke,
    <strong
      >Flights are programs that generate the desired Kubernetes resources in either JSON or YAML format and output them
      to stdout</strong
    >. Flights are typically packaged as
    <strong><a href="/yoke-website/pages/concepts.html#why-wasm">WebAssembly (wasm) executables </a></strong>, with Yoke
    embedding Wazero, a zero-dependency wasm runtime for Go, to execute these programs.
  </p>

  <p>
    Sharing packages is the same as sharing code. Package components can be distributed and versioned using the
    respective language's ecosystem package manager, such as npm, cargo, or Go modules.
    <strong>Any language that compiles to wasm enjoys first-class support in Yoke</strong>. If your chosen language does
    not compile to wasm, you can still invoke the program and pipe the output directly to Yoke. However, this approach
    comes with certain drawbacks, including potential issues related to portability and security.
  </p>
</section>

<section class="container">
  <h2>Why Yoke? Why Another Package Manager?</h2>
  <p>
    As the DevOps ecosystem transitions from a focus on DevOps to platform engineering, our tools for interfacing with
    Kubernetes (K8s) must evolve accordingly. Describing Kubernetes resources through text templates represents the
    minimum standard we have set. However, it is evident that this approach is not tailored with software engineering
    practices in mind. It lacks essential features such as proper type safety, compiler guarantees, validation, testing,
    autocompletion, and consistent IDE support.
  </p>
  <p>
    The crucial observation to note is that Kubernetes (K8s) resources differ fundamentally from web pages or emails.
    So, why do we use templates as if they were? These files represent diverse APIs supported by Kubernetes; in essence,
    they are structured data.
    <strong>The most effective tools for handling structured data are programming languages</strong>.
  </p>
</section>
